	\section{Pseudocódigo}
	
	\subsection{algoritmo principal}
	
	\begin{algorithm}[H]
		\caption{Sistema Colonia Hormigas}
		\begin{algorithmic}
			\STATE $matrizFeromonas \leftarrow InicializarFeromona()$
			\WHILE {iteracionesRealizadas$<$= limiteIteraciones $\wedge$  tiempoEjecucion $<$= limiteTiempoEjecucion}
			\STATE $colonia \leftarrow InicializarColonia()$
			\FOR {i=1; i$<$tamñoHormiga; i++}
			\FOR {$hormiga \in colonia$}
			\STATE $lrc \leftarrow GenerarLRC(hormiga)$
			\STATE AplicarReglaTransicion(lrc, hormiga)
			\ENDFOR
			\STATE ActualizarFeromonaLocal()
			\ENDFOR
			\STATE TareasDemonio()
			\STATE $\emptyset \leftarrow colonia$
			\STATE $iteracionesRealizadas \leftarrow iteracionesRealizadas+1$
			\ENDWHILE	
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}Lo primero que realiza el algoritmo es inicializar la matriz de feromonas con el valor inicial. Esta tarea la realiza la función "InicializarFeromona()", la matriz de feromonas se almacena en la variable "matrizFeromonas". El valor inicial de feromona se pasa como parámetro del programa.
	
	\paragraph{}A continuación, entramos en un bucle while cuyas condiciones de parada son: las iteraciones realizadas y el tiempo de ejecución del algoritmo. En el caso de las iteraciones realizadas, almacenadas en la variable "iteracionesRealizadas",  deben ser inferiores al límite almacenado en la variable "limiteIteraciones". El valor de "limiteIteraciones" se pasa como parámetro del programa. En el caso del tiempo de ejecución, que se almacena en la variable "tiempoEjecucion", debe de ser inferior al valor almacenado en la variable "limiteTiempoEjecucion". El valor de "limiteTiempoEjecucion" se pasa como parámetro del programa.
	
	\paragraph{}Cada vez que empieza una nueva iteración del bucle, lo primero que se realiza es inicializar la colonia de hormigas. La colonia se almacena en la variable "colonia" y la función encargada de inicializarla es "InicializarColonia()".
	
	\paragraph{}Una vez inicializada la colonia, iniciamos dos bucles for. El primero se ejecutará hasta que el valor de "i" alcance el número de elementos que debe contener cualquier solución (parámetro del programa, almacenado en la variable "tamañoHormiga"). El segundo bucle for recorrerá cada una de las hormigas pertenecientes a la variable "colonia".
	
	\paragraph{}Lo primero que realizamos es almacenar en la variable "lrc" la lista de candidatos restringida de la hormiga, calculada por la función "GenerarLRC(hormiga)".
	
	\paragraph{}Una vez almacenada la lista restringida, seleccionamos uno de los candidatos que contiene aplicando la regla de la transición y lo añadimos como parte de la solución de la hormiga. La función que realiza dicha tarea es "AplicarReglaTransicion(lrc,hormiga)".
	
	\paragraph{}Se finaliza el bucle for interior y la función "ActualizarFeromonaLocal()" se encarga de actualizar la feromona local de todas las hormigas después de haber añadido un nuevo elemento.
	
	\paragraph{}Una vez finalice el bucle for tendremos todas las hormigas completas, por lo que pasamos a seleccionar la mejor hormiga de la colonia y realizar la actualización de la feromona global. La función encargada de dichas tareas es "TareasDemonio()".
	
	\paragraph{}Para finalizar el bucle while, vaciamos la variable "colonia" y actualizamos el valor de la variable "iteracionesRealizadas".
	
	\subsection{Inicialización de la matriz de feronoma}
	
	\paragraph{Salida}Devuelve la matriz de feromonas inicializada.
	
	\begin{algorithm}[H]
		\caption{InicializarFeromona()}
		\begin{algorithmic}
			\FOR {i=0; i$<$tamañoMatriz; i++}
			\FOR {j=0; i$<$tamañoMatriz; j++}
			\STATE $matrizFeromonas[i][j] \leftarrow feromonaInicial$
			\ENDFOR
			\ENDFOR
			\RETURN matrizFeromonas
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}El funcionamiento de esta función es trivial: se inicializan todos los elementos de la matriz de feromonas con el valor de "feromonaInicial" (parámetro del programa).
	
	\newpage
	
	\subsection{Inicialización de la colonia de hormigas}
	
	\paragraph{Salida}Devuelve la colonia de hormigas inicializada.
	
	\begin{algorithm}[H]
		\caption{InicializarColonia()}
		\begin{algorithmic}
			\WHILE{colonia.tamaño()$<$tamañoColonia}
			\STATE$hormiga \leftarrow \emptyset$
			\STATE$primerElemento \leftarrow GenerarEnteroAleatorio()$
			\STATE$hormiga \leftarrow hormiga \cup \{primerElemento\}$
			\STATE$colonia \leftarrow colonia \cup \{hormiga\}$
			\ENDWHILE
			\RETURN colonia
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}El funcionamiento de esta función es trivial: se inicializan todas las hormigas con un elemento generado aleatoriamente con la función "GenerarEnteroAleatorio()". Cuando se tengan "tamañoColonia" (parámetro del programa) hormigas inicializadas, se devuelve la colonia como resultado.
	
	\subsection{Generación de la Lista Restringida de Candidatos}
	
	\paragraph{Entrada}La hormiga para la que se quiere obtener su Lista Restringida de Candidatos.
	
	\paragraph{Salida}Devuelve la Lista Restringida de Candidatos "lrc".
	
	\begin{algorithm}[H]
		\caption{GenerarLRC(hormiga)}
		\begin{algorithmic}
			\STATE$lrc \leftarrow \emptyset$
			\STATE$noSeleccionados \leftarrow \emptyset$
			\STATE$min \leftarrow +\infty$
			\STATE$max \leftarrow -\infty$
			\FOR{i=0;i$<$tamañoMatriz;i++}
			\IF{$i \notin hormiga$}
			\STATE $aporte \leftarrow 0$
			\FOR{$elemento \in hormiga$}
			\STATE$aporte \leftarrow aporte + MatrizCostes[elemento][i]$
			\ENDFOR
			\IF{min == +$\infty$}
			\STATE$max \leftarrow aporte$
			\STATE$min \leftarrow aporte$
			\ENDIF
			\IF{aporte$>$max}
			\STATE$max \leftarrow aporte$
			\ELSIF{aporte$<$min}
			\STATE$min \leftarrow aporte$
			\ENDIF
			\STATE$noSeleccionados\leftarrow noSeleccionados \cup \{i,aporte\}$
			\ENDIF
			\ENDFOR
			\STATE$valorCorte \leftarrow min + delta *$(max - min)
			\FOR{$elemento \in noSeleccionados$}
			\IF{elemento.aporte$>$=valorCorte}
			\STATE$lrc \leftarrow lrc \cup {\{elemento\}}$
			\ENDIF
			\ENDFOR
			\RETURN lrc
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}Lo primero que se realiza es inicializar los valores de las variables "lrc", "noSeleccionados", "min" y "max"."lrc" almacena la Lista Restringida de Candidatos, "noSeleccionados" almacena todos los elementos del problema que no forman parte de la hormiga, "min" y "max" almacena el mínimo y máximo aporte encontrado hasta el momento.
	
	\paragraph{}Se recorren todos los elementos del problema y se comprueba que no se encuentren ya en la hormiga.
	
	\paragraph{}En el caso de que no se encuentren en la hormiga, se actualiza el valor de la variable "aporte" a cero y se calcula el coste que aportaría a la hormiga si lo incluyéramos en ella. Este coste se almacena en la variable "aporte".
	
	\paragraph{}A continuación, se comprueba que "aporte" no sea mayor que "max" o menor que "min". En el caso de que se cumpla una de estas dos condiciones, se actualiza el valor de "max" o de "min" dependiendo del caso.
	
	\paragraph{}Para finalizar, se añade el elemento junto su aporte a la variable "noSeleccionados".
	
	\paragraph{}Se realiza lo anterior hasta que se hayan recorrido todos los elementos del problema.
	
	\paragraph{} Lo siguiente que se realiza es el cálculo de "valorCorte" aplicando la siguiente fórmula, siendo "delta" un parámetro del programa:
	
	\begin{center}
		$valorCorte = min + delta * ( max - min )$
	\end{center}
	
	\paragraph{}Para cada elemento de "noSeleccionados", se comprueba que su aporte sea mayor que "valorCorte". Si se da este caso, se añade el elemento a la Lista Restringida de Candidatos. Cuando se haya hecho la comprobación de todos los elementos, "lrc" habrá sido generada.
	
	\paragraph{}Una vez se haya realizado esto último, se devuelve la Lista Restringida de Candidatos generada como resultado de la ejecución de la función.
	
	\newpage
	
	\subsection{Aplicacion de la regla de transición}
	
	\paragraph{Entradas}La Lista Restringida de Candidatos "lrc", y la hormiga a la que queremos aplicar la regla de la transición. 
	
	\begin{algorithm}[H]
		\caption{AplicarReglaTransicion(lrc, hormiga)}
		\begin{algorithmic}
			\STATE$probabilidadesTransicion \leftarrow \emptyset$
			\STATE$sumatoria \leftarrow 0$
			\STATE$q \leftarrow GenerarFloatAleatorio()$
			\IF{q0$<$=q}
			\STATE$elemento \leftarrow 0$
			\STATE$mayorValor\leftarrow -\infty$
			\FOR{$elementoLrc \in lrc$}
			\STATE$sumatoria \leftarrow 0$
			\FOR{$elementoHormiga \in hormiga$}
			\STATE$sumatoria \leftarrow sumatoria + (matrizFeromonas[elementoHormiga][elementoLrc]^{alfa} * matrizCostes[elementoHormiga][elementoLrc]^{beta})$
			\ENDFOR
			\IF{mayorValor$<$=sumatoria}
			\STATE$mayorValor \leftarrow sumatoria$
			\STATE$elemento \leftarrow elementoLrc$
			\ENDIF
			\ENDFOR
			\STATE$hormiga \leftarrow hormiga \cup \{elemento\}$
			\ELSE
			\FOR{$elementoLrc \in lrc$}
			\STATE$valorSuperior \leftarrow 0$
			\FOR{$elementoHormiga \in hormiga$}
			\STATE$valorSuperior \leftarrow valorSuperior + (matrizFeromonas[elementoHormiga][elementoLrc]^{alfa} * matrizCostes[elementoHormiga][elementoLrc]^{beta})$
			\ENDFOR
			\STATE$sumatoria \leftarrow sumatoria + valorSuperior$
			\STATE$probabilidadesTransicion \leftarrow probabilidadesTransicion \cup \{valorSuperior\}$
			\ENDFOR
			\STATE$indice \leftarrow 0$
			\FOR{$valor \in probabilidadesTransicion$}
			\STATE$probabilidad \leftarrow (valor/sumatoria)$
			\STATE$probabilidadesTransicion[indice]\leftarrow probabilidad$
			\STATE$indice \leftarrow indice+1$
			\ENDFOR
			\STATE$uniforme \leftarrow GenerarFloatAleatorio()$
			\STATE$indice \leftarrow 0$
			\STATE$probabilidadAcumulada \leftarrow 0$
			\FOR{$probabilidad \in probabilidadesTransicion$}
			\STATE$probabilidadAcumulada \leftarrow probabilidadAcumulada+probabilidad$
			\IF{uniforme$<$= probabilidadAcumulada}
			\STATE$hormiga \leftarrow hormiga \cup \{lrc[indice]\}$
			\ENDIF
			\STATE$indice \leftarrow indice+1$
			\ENDFOR
			\STATE$lrc \leftarrow \emptyset$
			\ENDIF
		\end{algorithmic}
	\end{algorithm}

	\newpage

	\paragraph{}Esta función selecciona uno de los candidatos de la Lista Restringida de Candidatos y la añade a la hormiga aplicando la siguiente regla:

	\begin{equation}
	p_{k}(r,s)= \left\lbrace
	\begin{array}{ll}
	\textup{si } q0 \leq q & \textup{arg }max_{u \in J_{k}(r)}\{(feromona_{ru})^{alfa}*(heuristica_{ru})^{beta}\}\\
	\textup{en otro caso } & p'_{k}(r,s)
	\end{array}
	\right.
	\end{equation}

	\begin{equation}
	p'_{k}(r,s)= \left\lbrace
	\begin{array}{ll}
	\textup{si } s \in J_{k}(r) & \frac{(feromona_{rs})^{alfa}*(heuristica_{rs})^{beta}}{\sum_{u \in J_{k}(r)}(feromona_{ru})^{alfa}*(heuristica_{ru})^{beta}}\\
	\textup{en otro caso } & 0
	\end{array}
	\right.
	\end{equation}
	
	\paragraph{}Lo primero que se realiza en la función es inicializar las variables "probabilidadesTransicion", "sumatoria" y "q". "probabilidadesTransicion" almacenará la distribución de probabilidades de todos los candidatos y su valor inicial será el conjunto vacío. "sumatoria" almacenará la suma de las dos ecuaciones anteriores y su valor inicial será 0. "q" almacenará un aleatorio generado por la función "GeneraFloatAleatorio()".
	
	\paragraph{}Después de esto se comprueba si "q0" es menor o igual que "q". Si se da este caso se realiza lo siguiente.
	
	\paragraph{}Se inicializa "elemento" a 0 y "mayorValor" a menos infinito. "elemento" se encargará de almacenar el elemento de "lrc" seleccionado. "mayorValor" almacenará el mayo resultado calculado hasta el momento.
	
	\paragraph{}Para cada elemento perteneciente a la Lista Restringida de Candidatos se calcula la fórmula de la transición respecto a cada elemento almacenado en la hormiga, y se adiciona cada resultado a la variable "sumatoria".
	
	\paragraph{}Una vez obtenido el valor de "sumatoria", se comprueba si mejora "mayorValor". Si se da este caso, se actualiza "mayorValor" con "sumatoria" y se guarda el elemento de "lrc" en la variable "elemento".
	
	\paragraph{}Cuando se haya recorrido toda la Lista Restringida de Candidatos se añade a la hormiga el mejor elemento de "lrc", almacenado en "elemento".
	
	\paragraph{}En el caso de que "q" sea menor que "q0" se realiza los pasos que se describen a continuación.
	
	\paragraph{}Se inicia un bucle for que recorrerá todos los elementos de la Lista Restringida de Candidatos.
	
	\paragraph{}Dentro de este bucle se inicializa la variable "valorSuperior" a 0, esta variable almacenará el numerador de la fórmula.
	
	\paragraph{}A continuación se recorren todos los elementos de la hormiga y se realiza el cálculo de la fórmula del numerador, el valor obtenido se adiciona a "valorSuperior".
	
	\paragraph{}Una vez se hayan hecho todos los cálculos con todos los elementos de la hormiga, se adiciona a "sumatoria" la variable "valorSuperior" y se añade a "probabilidadesTransicion" esta última.
	
	\paragraph{}Una vez terminado el bucle for, se inicializa la variable "indice" a 0, que hará las funciones de iterador.
	
	\paragraph{}Se inicia un nuevo bucle for que recorrerá todos los valores almacenados en la variable "probabilidadesTransición".
	
	\paragraph{}Dentro de este bucle, se calcula la probabilidad de cada elemento de "lrc" con los valores almacenados en "probabilidadesTransicion" y "sumatoria", y se almacenan en la misma "probabilidadesTransicion". Una vez realizado esto, "probabilidadesTransicion" habrá pasado de almacenar los numeradores de la formula de transición de cada elemento de "lrc" a almacenar las probabilidades calculadas para cada elemento de "lrc".
	
	\paragraph{}Al terminar de recorrer todos los elementos de "probabilidadesTransicion", se genera aleatoriamente un número decimal entre 0 y 1 y se almacena en la variable "uniforme". Se inicializan las variables "indice" y "probabilidadAcumulada" a 0. "indice" sigue desempeñando la misma función y "probabilidadAcumulada" almacena la sumatoria de todos los valores de "probabilidadesTransicion" que se hayan recorrido hasta el momento.
	
	\paragraph{}Para terminar se inicializa un último bucle for en el que se comprobará a qué elemento de la Lista Restringida de Candidatos corresponde el valor de "uniforme" generado haciendo uso de la distribución de probabilidades almacenada en "probabilidadesTransicion". Cuando sepamos el elemento, se añade a la hormiga como parte de la solución y se termina la ejecución de la función.
	
	\subsection{Actualización de la feromona local}
	
	\begin{algorithm}[H]
		\caption{ActualizarFeromonaLocal()}
		\begin{algorithmic}
			\FOR{$hormiga \in colonia$}
			\STATE$elementoB \leftarrow hormiga.UltimoElmento()$
			\FOR{i=0;i$<$=hormiga.tamaño()-1;i++}
			\STATE$elementoA\leftarrow hormiga[i]$
			\STATE$valorAnterior \leftarrow matrizFeromonas[elementoA][elementoB]$
			\STATE$matrizFeromonas[elementoA][elementoB]\leftarrow (1-rho)*valorAnterior+phi*(costeGreedy)$
			\STATE$matrizFeromonas[elementoB][elementoA]\leftarrow matrizFeromonas[elementoA][elementoB]$
			\ENDFOR
			\ENDFOR
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}Se recorren todas las hormigas de la colonia y se realizan las operaciones que se describen a continuación.
	
	\paragraph{}Se guarda en la variable "elementoB" el último elemento introducido en la hormiga.
	
	\paragraph{}A continuación, se inicia un nuevo bucle for que recorre todos los elementos pertenecientes a la hormiga.
	
	\paragraph{}Dentro de este bucle, se guarda en la variable "elementoA" el elemento 'i' de la hormiga y el valor de la feromona del arco "elementoA"-"elementoB" en la variable "valorAnterior". 
	
	\paragraph{}Se actualiza el valor de la feromona del arco "elementoA"-"elementoB", almacenada en "matrizFeromonas" con el resultado de la siguiente función:
	
	\begin{center}
		$Feromona(elementoA,elementoB) = (1-\phi)*valorAnterior+\phi*costeGreedy$
	\end{center}

	\paragraph{}Una vez se haya actualizado la feromona de todos los arcos nuevos de todas las hormigas, se tendrá "matrizFeromonas" actualizada localmente como resultado de la ejecución de la función.
	
	\newpage
	
	\subsection{Tareas demonio}
	
	\begin{algorithm}[H]
		\caption{TareasDemonio()}
		\begin{algorithmic}
			\STATE$mejorHormiga \leftarrow EvaluarMejorHormiga()$
			\STATE ActualizarFeromonaGlobal(mejorHormiga())
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}El funcionamiento de esta función es trivial: se obtiene la mejor hormiga haciendo uso de la función "EvaluarMejorHormiga()" y se actualiza la feromona global.
	
	\subsection{Obtener la mejor hormiga de la colonia}
	
	\paragraph{Salida}Se devuelve la mejor hormiga de la colonia.
	
	\begin{algorithm}[H]
		\caption{EvaluarMejorHormiga()}
		\begin{algorithmic}
		\STATE$mejorHormiga \leftarrow 0$
		\STATE$valorMejor \leftarrow 0$
		\FOR{$hormiga \in colonia$}
		\STATE$coste \leftarrow CalcularCoste(hormiga)$
		\IF{coste$>$= valorMejor}
		\STATE$mejorHormiga \leftarrow hormiga$
		\STATE$valorMejor \leftarrow coste$
		\ENDIF
		\ENDFOR	
		\RETURN mejorHormiga
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}Se inicializan las variables "mejorHormiga" y "valorMejor" a 0. "mejorHormiga" almacenará la hormiga con mejor coste de la colonia. "valorMejor" almacenará el coste de la mejor hormiga encontrada.
	
	\paragraph{}Se recorren todas las hormigas pertenecientes a la colonia, se calcula el coste de cada hormiga con "CalcularCoste(hormiga)" y, si se mejora "valorMejor", se guarda la hormiga y su coste en las variables destinadas a tal efecto.
	
	\paragraph{}Para finalizar, cuando se haya ejecutado el bucle for, se devuelve "mejorHormiga" como resultado de la ejecución.
	
	\subsection{Actualización de la feromona global}
	
	\paragraph{Entrada}La mejor hormiga de la colonia.
	
	\begin{algorithm}[H]
		\caption{ActualizarFeromonaGlobal(mejorHormiga)}
		\begin{algorithmic}
			\FOR{i=0;i$<$tamañoMatriz;i++}
			\FOR{j=0;j$<$tamañoMatriz;j++}
			\STATE$valorAnterior \leftarrow matrizFeromonas[i][j]$
			\STATE$matrizFeromonas[i][j] \leftarrow (1-rho)*valorAnterior$
			\STATE$matrizFeromonas[j][i] \leftarrow matrizFeromonas[i][j]$
			\ENDFOR
			\ENDFOR
			\STATE$coste \leftarrow CalcularCoste(mejorHormiga)$
			\FOR{i=0;i$<$mejorHormiga.Tamaño()-1;i++}
			\FOR{j=i+1;j$<$mejorHormiga.Tamaño();j++}
			\STATE$matrizFeromonas[i][j]\leftarrow matrizFeromonas[i][j] + rho*coste$
			\STATE$matrizFeromonas[j][i] \leftarrow matrizFeromonas[i][j]$
			\ENDFOR
			\ENDFOR
		\end{algorithmic}
	\end{algorithm}

	\paragraph{}En los dos primeros bucles for se recorre toda la matriz de feromonas evaporando el valor que contenía cada celda por el resultante de la siguiente función:
	
	\begin{center}
		$EvaporacionFeromona(i,j) = (1-\rho)*valorAnterior$
	\end{center}

	\paragraph{}Una vez evaporada toda la matriz de feromonas, se procede a adicionar feromona a todos los arcos pertenecientes a la mejor hormiga de la colonia.
	
	\paragraph{}Para este propósito se almacena el coste de la hormiga, haciendo uso de "CalcularCoste(mejorHormiga)", en la variable "coste".
	
	\paragraph{}A continuación, haciendo uso de un doble bucle for, recorremos todos los arcos de la hormiga en la matriz de feromonas y añadimos la feromona resultante de la siguiente función:
	
	\begin{center}
		$AdicionFeromona = \rho*coste$
	\end{center}

	\paragraph{}Cuando se hayan ejecutado los dos bucles for, tendremos la matriz de feromonas actualziada.
	
	\newpage